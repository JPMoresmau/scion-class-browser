-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Web Application Interface.
--   
--   Provides a common protocol for communication between web aplications
--   and web servers.
@package wai
@version 0.4.1


-- | This module defines a generic web application interface. It is a
--   common protocol between web servers and web applications.
--   
--   The overriding design principles here are performance and generality .
--   To address performance, this library is built on top of the enumerator
--   and blaze-builder packages. The advantages of enumerators over lazy IO
--   have been debated elsewhere and so will not be addressed here.
--   However, helper functions like <a>responseLBS</a> allow you to
--   continue using lazy IO if you so desire.
--   
--   Generality is achieved by removing many variables commonly found in
--   similar projects that are not universal to all servers. The goal is
--   that the <a>Request</a> object contains only data which is meaningful
--   in all circumstances.
--   
--   Please remember when using this package that, while your application
--   may compile without a hitch against many different servers, there are
--   other considerations to be taken when moving to a new backend. For
--   example, if you transfer from a CGI application to a FastCGI one, you
--   might suddenly find you have a memory leak. Conversely, a FastCGI
--   application would be well served to preload all templates from disk
--   when first starting; this would kill the performance of a CGI
--   application.
--   
--   This package purposely provides very little functionality. You can
--   find various middlewares, backends and utilities on Hackage. Some of
--   the most commonly used include:
--   
--   <ul>
--   <li><i>warp</i> <a>http://hackage.haskell.org/package/warp</a></li>
--   <li><i>wai-extra</i>
--   <a>http://hackage.haskell.org/package/wai-extra</a></li>
--   <li><i>wai-test</i>
--   <a>http://hackage.haskell.org/package/wai-test</a></li>
--   </ul>
module Network.Wai

-- | Information on the request sent by the client. This abstracts away the
--   details of the underlying implementation.
data Request
Request :: Method -> HttpVersion -> ByteString -> ByteString -> ByteString -> Int -> RequestHeaders -> Bool -> SockAddr -> [Text] -> Query -> Request
requestMethod :: Request -> Method
httpVersion :: Request -> HttpVersion

-- | Extra path information sent by the client. The meaning varies slightly
--   depending on backend; in a standalone server setting, this is most
--   likely all information after the domain name. In a CGI application,
--   this would be the information following the path to the CGI executable
--   itself. Do not modify this raw value- modify pathInfo instead.
rawPathInfo :: Request -> ByteString

-- | If no query string was specified, this should be empty. This value
--   <i>will</i> include the leading question mark. Do not modify this raw
--   value- modify queryString instead.
rawQueryString :: Request -> ByteString

-- | Generally the host requested by the user via the Host request header.
--   Backends are free to provide alternative values as necessary. This
--   value should not be used to construct URLs.
serverName :: Request -> ByteString

-- | The listening port that the server received this request on. It is
--   possible for a server to listen on a non-numeric port (i.e., Unix
--   named socket), in which case this value will be arbitrary. Like
--   <a>serverName</a>, this value should not be used in URL construction.
serverPort :: Request -> Int
requestHeaders :: Request -> RequestHeaders

-- | Was this request made over an SSL connection?
isSecure :: Request -> Bool

-- | The client's host information.
remoteHost :: Request -> SockAddr

-- | Path info in individual pieces- the url without a hostname/port and
--   without a query string, split on forward slashes,
pathInfo :: Request -> [Text]

-- | Parsed query string information
queryString :: Request -> Query
data Response
ResponseFile :: Status -> ResponseHeaders -> FilePath -> (Maybe FilePart) -> Response
ResponseBuilder :: Status -> ResponseHeaders -> Builder -> Response
ResponseEnumerator :: (forall a. ResponseEnumerator a) -> Response
type ResponseEnumerator a = (Status -> ResponseHeaders -> Iteratee Builder IO a) -> IO a
responseEnumerator :: Response -> ResponseEnumerator a
type Application = Request -> Iteratee ByteString IO Response

-- | Middleware is a component that sits between the server and
--   application. It can do such tasks as GZIP encoding or response
--   caching. What follows is the general definition of middleware, though
--   a middleware author should feel free to modify this.
--   
--   As an example of an alternate type for middleware, suppose you write a
--   function to load up session information. The session information is
--   simply a string map [(String, String)]. A logical type signatures for
--   this middleware might be:
--   
--   <pre>
--   loadSession :: ([(String, String)] -&gt; Application) -&gt; Application
--   </pre>
--   
--   Here, instead of taking a standard <a>Application</a> as its first
--   argument, the middleware takes a function which consumes the session
--   information as well.
type Middleware = Application -> Application
data FilePart
FilePart :: Integer -> Integer -> FilePart
filePartOffset :: FilePart -> Integer
filePartByteCount :: FilePart -> Integer
responseLBS :: Status -> ResponseHeaders -> ByteString -> Response
instance Typeable Request
instance Typeable Response
instance Show Request
instance Show FilePart